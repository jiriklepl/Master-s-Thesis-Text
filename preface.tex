\documentclass[12pt,a4paper]{report}
\setlength\textwidth{145mm}
\setlength\textheight{247mm}
\setlength\oddsidemargin{15mm}
\setlength\evensidemargin{15mm}
\setlength\topmargin{-40mm}
\setlength\headsep{0mm}
\setlength\headheight{0mm}
\usepackage[a-2u]{pdfx}

%% Character encoding: usually latin2, cp1250 or utf8:
\usepackage[utf8]{inputenc}

%% Prefer Latin Modern fonts
\usepackage{lmodern}
\begin{document}
\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}

System programming is usually performed in languages that do not offer any support for generic programming. While some of these languages do offer such support, it is often very limited and its usefulness is almost nonexistent.

Take the language C, for example, if we want to write a generic algorithm in C, we have to resort to using preprocessor macros or \texttt{void *} pointers (pointers that can point to anything). The problem with macros is that they are just a simple text-rewriting tool with no understanding of the code and thus an incorrect use of them can lead to syntactically nonsensical codes. Compilers usually can trace what got rewritten into what, but these capabilities are not really reliable. Use of preprocessor macros in languages that offer some alternatives to it is generally discouraged and considered a bad design decision.

The problem with \texttt{void *} pointers is the lack of any type information (due to them being able to point to anything), they do not help the programmer avoid incorrect uses and they do not suggest what the data they point to could be. Similarly to that, the compilers that have to work with these pointers cannot make any assumptions on the nature of the data and without some outside information, they cannot sufficiently optimize the code. Contrary to this, if the pointers would be typed, let us say \texttt{int *} (this denotes a pointer that points to an integer), the compiler could assume that a different pointer, \texttt{float *} (this pointer points to real number in floating point representation), does not point to the same data as such data would not make sense (representations for integers and real numbers are generally not compatible). Determining whether two pointers can point to the same data is called \textit{alias analysis} and it is a source to many optimizations. And as we previously asserted, \texttt{void *} pointers do not allow for that.

We offer an alternative to the lack of generic features in programming languages for system programming by using a variation of \textit{Hindley-Milner} (HM) type system with type constructors and type-classes in a dialect of \textit{C--} language. This type system is best well-known from \textit{Haskell} (one of the most influential functional languages), and C-- serves as one of the possible backends of \textit{Glasgow Haskell Compiler} (GHC), Haskell's most popular compiler. C-- itself has a very minimal type system that, however, can give strong constraints on, for example, what registers should the target machine use, or what call conventions should the defined functions use. This serves as a good pseudo-assembler language (generally generated from higher-level languages, not intended for programmers), but it lacks the aforementioned support for generic programming.

We introduce the previously described variation of HM type system into C-- allowing the compiler to infer the necessary type annotations (which in the current version of C-- have to be explicit) and allowing for defining generic structures and algorithms. This will have an effect of significantly shortening various C-- programs and, hopefully, making it one of the languages viable for system programming. In more general scope, this thesis explores a not well-researched area and showcases a possible development.

\end{document}
