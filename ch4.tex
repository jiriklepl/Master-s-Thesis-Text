\chapter{Results and discussion}
\label{chap4}

In this chapter, we show the possibilities of use of the extended \cmm{}.

\section{Prototype compiler of typed \cmm{}}

\subsection{Type-inferring local declarations}

In the following code, the compiler correctly infers that \li{r} has to be typed \li{bits32} and that the return type of the procedure \li{gcd} is \li{bits32} as well.

\begin{lstlisting}
foreign "C" gcd(bits32 u, bits32 w) {
    auto r;

    while:
    if w != 0 {
        r = w;
        w = u % w;
        u = r;
        goto while;
    }

    return (u);
}
\end{lstlisting}

\subsection{Reduction of code}

Type inference allows us to write generic code, which is then correctly interpreted by the compiler and rewritten into an efficient code with correctly filled types.

\begin{lstlisting}
add(auto x, auto y) {
    return (x + y);
}

...

bits32 a1, b1;
auto c1;
a1 = 5;
b1 = 10;

// correctly infers that 'c1' has to be typed 'bits32'
// and add has to be 'add(bits32 _1, bits32 _2) -> bits32'
c1 = add(b1, c1);

bits32 a2, b2;
auto c2;
a2 = 5;
b2 = 10;

// correctly infers that 'c2' has to be typed 'bits64'
// and add has to be 'add(bits64 _1, bits64 _2) -> bits64'
c2 = add(b2, c2);
\end{lstlisting}

The code is ``monomorphized'' into code containing the following definitions, which replace the original definition of \li{add}:

\begin{lstlisting}
_Madd_$f$Lb32b32R$$Lt$Lb32R$R$(bits32 x, bits32 y) {
    return (x + y);
}
_Madd_$f$Lb64b64R$$Lt$Lb64R$R$(bits64 x, bits64 y) {
    return (x + y);
}
\end{lstlisting}

Each of these definitions is then referred to by the corresponding call statement (\li{c1 = add(b1, c1)} and \li{c2 = add(b2, c2)}). The names of the two definitions are ``mangled'' representations of the \li{add} procedure, their names reflect the types of their respective arguments.

\section{Typechecking structure fields}




\section{Typeclass-based resource management}



\section{Applicability to other languages}



\subsection{Subtyping in systems programming}

The subset of subtyping modelled by our proposed type system can be used to check and infer various secondary properties of objects. We demonstrated its use on constness and data kinds of the \cmm{} language. Connecting the analysis of these secondary properties to the type system allows for tying the constraints on these properties only to a particular typing (as defined in \cref{sec:typesystem}), for example, by defining each type class instance with a different set of constraints.

\subsection{C subtyping}

In the previous work (see \cite{klepl2020type}), we identified weakness of the then-used type system with regards to the \li{const} qualifier from the C language (see \cite{cstandard2018}). Do its semantics fit the type system we introduced in \cref{sec:typesystem}?

The semantics of the C \li{const} qualifier (as specified by \cite{cstandard2018}) quite differ from the constness introduced in \cref{const_kind_def}. For our purposes, we simplify the semantics into two cases:

\begin{enumerate}
    \item If the \li{const} qualifier is applied to a variable (for example, \li{char *const p}), the type of the variable is the same as if it was not \li{const}-qualified. Any attempt to assign to this variable is an undefined behavior. \label{constvar}

    \item If the \li{const} qualifier is applied to a type pointed to by a certain pointer (for example, \li{char const *p}), any assignments to the pointer from pointers pointing to a non-\li{const}-qualified version of the same type are valid and the two pointers have the same value afterwards. The reverse assignment would be, again, an undefined behavior. \label{pointerSubtype}

    In our formalism, this means that \li{T *} is less general than \li{T const *}.
\end{enumerate}

We can model the semantics of the case number \ref{pointerSubtype} (case number \ref{constvar} is identified syntactically) via introducing a new subtype dimension, which is only relevant to pointer types (in simplification; we could then generalize this to array types and other aggregate types), let us call this dimension the \emph{C-const dimension}.

\begin{defn}[C-const dimension]
    The C-const subtype dimension $C$ is defined by two constants $\mtt{NonConst}, \mtt{Const}$ and an ordering $\top = \mtt{Const} >_C \mtt{NonConst} = \bot$.

    This dimension is only relevant to pointer types, other types being either unconstrained or constrained to specifically one of the constants (which is then sometimes called canonical - see \cite{tiuryn1999subtyping}).
\end{defn}

In the following, we use $a \sim_\chi b$ as a shortcut for $a \leq_\chi b \land b \leq_\chi a$, where $\chi$ is a dimension of the type system.

\begin{itemize}
    \item Each type definition (or primitive type: for example, \li{int}) $t$ is constrained: $t \sim_C \mtt{NonConst}$ (on top of any other constraints).

    \item Any declaration \li{T const *} constrains the type $t$ of the declared variable: $(\forall \mtt{dimension}\ s, s \neq C. t \sim_s T\ast), t \sim_C \mtt{Const}$ (this models that applying \li{const} is idempotent).

    \item For (generalized) assignments with operand types $t_l, t_r$, we put $t_l \geq_s t_r$ for each dimension $s$ and $t_l \sim_T t_r$. (we say ``generalized assignments'' as we consider even actual arguments to procedures and return operands, etc.).
\end{itemize}

This models the semantics of the \li{const} qualifier in a possible C extension with polymorphism.

\subsection{Automatic resource management in practical systems programming}

We show how to use the results of this thesis to simplify the resource management in system programming languages.

The kernel coding style guide proposes the following convention:

\begin{quotation}[\xxx{add pointer to kernel group}]
  The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done. If there is no cleanup needed then just return directly.
\end{quotation}

We propose the automatic resource management features introduced by the extended \cmm{} as an alternative to this convention. The cleanup section is replaced by a definition of an resource-representing object and accompanying \li{drop} function.

In order to fully serve as a practical alternative to the \li{goto cleanup} pattern in a general case, we also introduce a special statement \li{dropped}. Our proposed \li{dropped} function takes a named alias to the object representing the resource and removes the implicit calls on all function exits following this statement, still allowing for explicit calls whenever the user specifies.

This can be easily ensured by the flow analysis algorithm which is already demonstrated in the prototype implementation. The way we propose this should be implemented is that the use of \li{dropped} statement is malformed if there exist alternative paths in the control flow to its corresponding function exits. This can be efficiently checked by a dfs search through the control-flow graph. Allowing alternative paths to the exit points affected by the \li{dropped} statement would have consequences on the code transparency (the programmer would have to be aware of the entirety of the procedure's control flow in order to know whether a \li{drop} action happens or not).

One possible improvement over the \li{goto cleanup} pattern is that this can easily scale with more actions tied to multiple resource-representing objects, each such action then possibly being prevented by a separate \li{dropped} statement on some subset of control flow paths.

\section{Comparison to other languages offering automatic resource management}

There are multiple constructs that implement the automatic resource management mechanism. We will look into two: \xxx{C++ RAII constructor/destructor} and \xxx{C\# try{}finally{...}}.
