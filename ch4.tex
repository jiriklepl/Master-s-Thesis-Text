\chapter{Results and discussion}

\section{Subtyping in systems programming}

The subset of subtyping modelled by our proposed type system can be used to check various secondary properties of objects. We demonstrated its use on constness and data kinds of the \cmm language. Connecting the analysis of these secondary properties to the type system allows for tying the constraints on these properties to a particular typing, for example, by defining each type class instance with a different set of constraints.

\section{Example of possible automatic resource management use in production systems programming}

We show how to use the results of this thesis to simplify the resource management in system programming languages.

The kernel coding style guide proposes the following convention:

\begin{quotation}[\xxx{add pointer to kernel group}]
  The goto statement comes in handy when a function exits from multiple locations and some common work such as cleanup has to be done. If there is no cleanup needed then just return directly.
\end{quotation}

We propose the automatic resource management features introduced by the extended \cmm{} as an alternative to this convention. The cleanup section is replaced by a definition of an resource-representing object and accompanying \li{drop} function.

In order to fully serve as a practical alternative to the \li{goto cleanup} pattern in a general case, we also introduce a special statement \li{dropped}. Our proposed \li{dropped} function takes a named alias to the object representing the resource and removes the implicit calls on all function exits following this statement, still allowing for explicit calls whenever the user specifies.

This can be easily ensured by the flow analysis algorithm which is already demonstrated in the prototype implementation. The way we propose this should be implemented is that the use of \li{dropped} statement is malformed if there exist alternative paths in the control flow to its corresponding function exits. This can be efficiently checked by a dfs search through the control-flow graph. Allowing alternative paths to the exit points affected by the \li{dropped} statement would have consequences on the code transparency (the programmer would have to be aware of the entirety of the procedure's control flow in order to know whether a \li{drop} action happens or not).

One possible improvement over the \li{goto cleanup} pattern is that this can easily scale with more actions tied to multiple resource-representing objects, each such action then possibly being prevented by a separate \li{dropped} statement on some subset of control flow paths.

\section{Comparison to other languages offering automatic resource management}

There are multiple constructs that implement the automatic resource management mechanism. We will look into two: \xxx{C++ RAII constructor/destructor} and \xxx{C\# try{}finally{...}}.
