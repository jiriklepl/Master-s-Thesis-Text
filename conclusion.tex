
\chapwithtoc{Conclusion}

\section*{Successfully solved assigned goals}

\begin{description}
    \small
    \item[Extend \cmm{} with parametric polymorphism with type classes] We achieved this goal successfully and we demonstrate parametric polymorphism with typeclasses in our results. We also extended the typeclasses to multi-parameter typeclasses, solving one of the issues identified in the previous work. We then extended this even further with user-specifiable functional dependencies on the multi-parameter typeclasses. This allows for more expressive code and stronger type constraints than regular typeclasses.

    \item[Extend \cmm{} with record types]  We extended the language with \li{struct} types inspired by C, but allowing for multiple aliases to fields. The field accessors are defined with as singleton method of classes parametrized by corresponding structs and their respective fields and with functional dependencies \li{struct -> field}, which solves the field-accessor-related issue identified in the previous work.

    \item[Extend \cmm{} with automatic resource management features] We extended the language with \li{new} specifier, which signifies that an object is to automatically undergo a predefined resource management action on each procedure exit. We also successfully experimented with introducing user-specified special cases to this mechanism and with various combinations with the type inference mechanism. We showed practical uses-cases for each of these further extensions.

    \item[The solution should simplify implementation of low-level software] We showed that the solution can be used to reduce the written code and we also discussed the effects on performance and showed the generic code does not constitute any runtime type checks or indirections.

    \item[The code written in the extended \cmm{} language will be compilable to LLVM] We showed many examples of the input code and the corresponding translation to LLVM. We also explained the steps necessary for such translation and discussed some optimizations that use the same primitives as the translation and which can be performed simultaneously with the semantic processing of the code for translation. The compiler also contains options \li{-f} and \li{-n} for running the compiler pipeline up to the flattening phase and just before the transcription to LLVM, respectively. These options help connect the input code to its LLVM representation.

    \item[The available features will be evaluated by demonstrational programs] In our results, we include an example for every claim we make about the extended \cmm{} in results or here. Furthermore, there are even more examples, that can be automatically executed by a script, in the supplementary repository \cite{klepl2022compiler}.

    \item[The available features will be compared with similarly-focused languages] We compared the features of the extended \cmm{} to C, the ``de facto'' standard system programming language and we discussed possible benefits of our approach to some common design patterns of C.

    We also compared the features of the extended \cmm{} to other languages offering support for generics, namely Java and Python. And we showed that our solution, contrasting these, does not require any runtime type information.

    We then compared the features of the extended \cmm{} to other languages offering automatic resource management, namely C++ and C\#. And discussed the differences in design decisions.

    Less-significantly, we compared the type system introduced into \cmm{} to the one we introduced into C in the previous work and we concluded that it solves the unreached goals of that work.
\end{description}

\section*{Tackled and not fully solved assigned goals}

\begin{description}
    \small
    \item[User-specifiable semantics of constants] We iteratively developed a subtyping system, with an attempt to model propagation of constants. The relevant theory suggested that even quite simple such systems are either undecidable or not time-efficiently solvable (examples: \cite{tiuryn1992subtype}, \cite{frey1997subtype}). This development was about  exploring the fragile balance between some practical usability and efficient solvability without ambiguities. The formulation we concluded on is solvable and without ambiguities, although not very practical for traditional systems languages. For each subprogram (strongly connected component of definitions and declarations) It works in two phases. The first phase solves the typings of all semantic nodes (typings are during this phase indistinguishable from types). The second phase then minimizes subtype inequalities of certain free variables in the given subprogram. This is solvable by graph algorithms that concern topology orderings.

    The prototype algorithm does not cover the proposed subtyping system. And furthermore, it was concluded that this system is incomplete for systems with first-class functions and pointers, as it, due to solvability, does not propagate inequalities onto derived types. \cite{tiuryn1992subtype}, \cite{frey1997subtype} conclude, such an approach would, without significant limitations, mean the system would not be efficiently solvable.
\end{description}

\section*{The overall quality of the solution}

In the prototype compiler, we focused on the assignment goals and on the goals the previous work did not manage to achieved. We also addressed concerns with stability and usability of the compiler included in the previous work. These concerns were mostly about compiler errors that apparently did not reflect the actual errors made by the user and about platform-specificity of the solution. The functionality of the compiler of the previous work was tied to some platform specifics which were not sufficiently reflected by the provided documentation. In the prototype compiler for this thesis, we address both these issues. The functionality of the compiler does not put any assumptions on the actual platform other than the code dependencies stated in included documentation. The concern with errors is addressed by introducing \li{ASTErrors} extensively used throughout the implementation, that on top of the specific also print out the assumed relevant location in the code that issues the error.

\section*{Practical uses of the solution}

We discussed practical use-cases of our solution in systems programming, specifically, in Linux kernel programming. We also discussed various general use-cases for polymorphism with type classes for reducing human-written by introducing polymorphic definitions and for automatic resource management. We supported these discussions by examples compiled using the prototype compiler and compared them to similar solutions of popular languages.

\section*{Future work}

Here we include the possible extensions to our solution that were outside of time constraints of our work.

\begin{description}
    \item[Existential types] We based our solution for type inference on deferred solving algorithm capable of solving existential types \cite{vytiniotis2011outsidein}. One natural course of future development could be trying to combine those with our extensions to the language. Existential types are demonstrated in imperative languages by \cite{grossman2002existential}.

    \item[Stronger subtyping system] We discussed some insufficiencies of the type system we developed. We leave for a future work a revised approach, which constitutes two constraint generation phases for each subprogram (strongly connected component of definitions and declarations), the first generating constraints for typings and the other, after all typings of the component are inferred, constraints for the subtypes, which is then followed by minimization of the inequality-constrained variables. The revised approach can generate stronger subtype constraints. We provide the necessary primitives for this revised approach.

    This goal would constitute further discussions that would compare subtypes, type-inferred secondary properties of types, to more conventional approaches of semantic analysis. As well as sufficient discussions for practical use-cases for subtypes.
\end{description}
