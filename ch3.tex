\chapter{Design}

\todo{PROC BC JO ALE PROC ZLEPSIT}

\section{Type System}

The type system is based on an extension of the HM type system with (multi-parameter) type classes and type constructors with monomorphic type kinds.

This is extended by adding a limited form of subtyping. In the new type system, the types are a result of the traditional typing together with added subtype dimensions and their subtype constraints.

\begin{defn}[Typing dimension]
    The typing $\mathbb{T}$ dimension is a lattice with type instantiation serving as the $\leq$ operation and $\forall a . a$ being the top element.
\end{defn}

\begin{defn}[Subtype dimension]
    The subtype dimension $\mathbb{S}$ is required to be a bounded lattice independent on the type-inferred program. We can then simply extend the definition to apply to user-defined subtype dimensions, but that is not within the scope of this thesis.

    In the type system specific to this thesis, we use two subtype dimensions: data kinds $\mathbb{K}$ and constnesses $\mathbb{C}$.
\end{defn}

\begin{defn}[Types]
    We then formally define types $\widehat{\mathbb{T}}$ as a composition of typings and subtype dimensions:
    
    Let (distinct) $\mathbb{S}_1, \dots \mathbb{S}_n$ be all subtype dimensions recognized by the system, then a type $\tau$ is defined as $\tau = \tau_T \cap \tau_{S_1} \cap \cdots \tau_{S_n}$; where $\tau_T \in \mathbb{T}$ is called the typing of $\tau$ and $\tau_{S_1} \in \mathbb{S}_1, \dots \tau_{S_n} \in \mathbb{S}_n$ are called subtype coordinates of $\tau$ in the respective dimensions. The operation $\cap$ is a meet operation on constraints $\tau_T, \tau_{S_1}, \dots \tau_{S_n}$ such that the result is unique for each combination.
\end{defn}

\begin{defn}[Subtype dimension comparison]
    We define a transitive and reflective binary relation on types $\leq_S$ ($\tau \leq_S \sigma \iff \tau_S \wedge \sigma_S = \tau_S\ \mathrm{and}\ \tau_S \vee \sigma_S = \sigma_S$, where $\tau_S$ and $\sigma_S$ are the types' respective subtype coordinates in the dimension $\mathbb{S}$) which states that one type is less general in the given dimension than another type.

    We extend this definition to other comparison operators as well. Note that $\tau =_S \sigma \not\Rightarrow \tau = \sigma$, but indeed $\tau = \sigma \Rightarrow \tau =_S \sigma$.

    We use the operator $\leq_S$ as a type constraint and we allow one of the operands be an element of $\mathbb{S}$.
\end{defn}

\begin{lemma}[Type equality]
    Let (distinct) $\mathbb{S}_1, \dots \mathbb{S}_n$ be all subtype dimensions recognized by the system. Then for two types $\tau, \sigma$ with the same typing: $\tau = \sigma \iff \forall i \in \{1, \dots n\} . \tau =_{S_n} \sigma$. 
\end{lemma}

\begin{lemma}[Subtype dimension constraint combining]
    If a type $\tau$ is upper-bounded in a subtype dimension by multiple upperbounds: $\tau \leq_S s_1$, $\tau \leq_S s_2$, then we can replace such constraints with a single $\tau \leq_S (s_1 \wedge s_2)$. Similarly for lowerbounds and the join operation.

    Note that given multiple upperbounds and lowerbounds, the set of viable types can be empty. 
\end{lemma}

\section{Inference}

\begin{defn}[Type variables]
    $\mathbb{V}$ is the space of type variables given as follows, each (sub)type considered by the inference algorithm will be assigned a type variable representing it:
    \begin{grammar}{\mathbb{V} \Rightarrow v}{}
        \mid \mathbb{V} '
    \end{grammar}

    The variables follow the obvious lexical ordering (based on their length).
\end{defn}

\begin{defn}[Typings]
    $\mathbb{T}$ is the space of typings given as follows, they specify that a type follows the same typing as a different type:
    \begin{table}[H]
        \begin{grammar}{\mathbb{T} \Rightarrow }{Typing}
            \mathbb{V} & Variable \\
            \left[\mathbb{T}\right] \to \mathbb{T} & Function \\
            \mid \left[\mathbb{T}\right] & Tuple \\
            \mid \mathbb{T}\ \mathbb{T} & Application \\
            \cdots
        \end{grammar}
    \end{table}
\end{defn}

\begin{defn}[Types]
    Types use the same language as typings and thus the space $\mathbb{T}$ is considered the space of types as well as the space of typings.
\end{defn}


\begin{defn}[Primitive patterns]
    $\mathbb{P}$ is the space of primitive patterns given as follows, they represent the topmost level of a type's structure:
    \begin{table}[H]
        \begin{grammar}{\mathbb{P} \Rightarrow }{Primitive pattern}
            \left[\mathbb{V}\right] \to \mathbb{V} & Function \\
            \mid \left[\mathbb{V}\right] & Tuple \\
            \mid \mathbb{V}\ \mathbb{V} & Application \\
            \cdots
        \end{grammar}
    \end{table}
\end{defn}

\begin{lemma}[Primitive patterns]
    \label{typesObs}
    Every type $\tau \in \mathbb{T}$ can be equally represented by a type variable and a set of primitive patterns $P \in \mathbb{P}$. This also provides us the way to unambiguously identify the type $\tau'$ of a subexpression $x'$ ($x' : \tau')$ of the expression $x$ ($x : \tau$).
\end{lemma}

\begin{defn}[Constnesses]
    $\mathbb{C}$ is the space of constnesses given as follows:
    \begin{table}[H]
        \begin{grammar}{\mathbb{C} \Rightarrow }{Constness}
            \mathtt{Regular} & \textit{for regular runtime variables} \\
            \mid \mathtt{Linkexpr} & \textit{for variables that are to be known during linkage} \\
            \mid \mathtt{Constexpr} & \textit{for variables that are to be known during compilation}
        \end{grammar}
    \end{table}

    Constness of a type specifies the time when an object assigned the type is to be computed.

    We define ordering on constnesses: $\mathtt{Constexpr} < \mathtt{Linkexpr} < \mathtt{Regular}$.
\end{defn}

\begin{defn}[Data kinds]
    $\mathbb{K}$ is the space of data kinds, it is a subset of the power set of a set of registers.

    The kinds are ordered by the relation of being a subset. We put $\mathtt{GenericKind}$ as the superset of all possible kinds and $\mathtt{EmptyKind}$ as the subset of all possible kinds.
\end{defn}

\begin{defn}[Type properties]
    $\mathbb{D}$ is the space of type properties given as follows:
    \begin{algorithmic}
        \State{$\mathbb{D} \Rightarrow (typing: \mathbb{T}, constness: \mathbb{V}, kind: \mathbb{V})$}
    \end{algorithmic}

    This states that a type has a certain typing, constness of a certain type and a kind of a certain type.

    The functions that project objects from $\mathcal{D}$ to the respective properties are called $t$, $c$, $k$.
\end{defn}



\begin{defn}[Facts]
    $\mathbb{F}$ is the space of flat facts given as follows:
    \begin{table}[H]
        \begin{grammar}{\mathbb{F} \Rightarrow }{Flat facts}
            \mathbb{T} \sim \mathbb{T} & Unification: \textit{specifies that the types have to be identical} \\
            \mathbb{T} \sim_T \mathbb{T} & Typing unification: \textit{specifies that the types have to follow the same typing} \\
            \mathbb{T} \leq_K \mathbb{T} & SubKind: \textit{specifies that the right operand has more general data kind than the first operand} \\
            \mathbb{T} \leq_C \mathbb{T} & SubConst: \textit{specifies that the right operand has more general constness than the first operand} \\
            \mathbb{K} \leq_K \mathbb{T} \leq_K \mathbb{K} & Kind bounds: \textit{specifies that the type has a data kind from the given range} \\
            \mathbb{C} \leq_C \mathbb{T} \leq_C \mathbb{C} & Const bounds: \textit{specifies that the type has a constness from the given range} \\
            C\ \mathbb{T} & Class constraint: \textit{specifies that the given constraint type (applied to a certain number of types - unless nullary) is valid} \\
            \mathbb{T} \leq_M \mathbb{T} & Instantiation: \textit{specifies that the left operand is monotype instance of the polytype right operand; note: this is satisfiable only if the right operand is indeed a polytype} \\
        \end{grammar}
    \end{table}

    Sometimes we will use derived facts like $\mathbb{T} \leq_K \mathbb{K}$, $\mathbb{T} =_K \mathbb{T}$, etc. These are either special cases of the aforementioned facts, or compositions of multiple facts. The most complicated derived fact we will use is the ``SubType'' fact, $\mathbb{T} \leq \mathbb{T}$, which is a combination of $\mathbb{T} \sim_T \mathbb{T}$, $\mathbb{T} \leq_K \mathbb{T}$ and $\mathbb{T} \leq_C \mathbb{T}$.

    It should be noted that, within the defined language, we cannot state the facts $\mathbb{T} \not\sim_T \mathbb{T}$, $\mathbb{T} \not\leq_K \mathbb{T}$, $\mathbb{T} \not\leq_C \mathbb{T}$ and $\mathbb{T} \not\leq_M \mathbb{T}$ and thus these (and similar ones) are not derived facts.

    $\mathbb{W}$ is the space of facts given as follows:

    \begin{table}[H]
        \begin{grammar}{\mathbb{W} \Rightarrow }{Facts}
            \mathbb{F} & Fact \\
            \forall \alpha_1, \dots \alpha_n . [\mathbb{F}] \Rightarrow [\mathbb{W}] & Nested facts: \textit{specifies that satisfying the given facts requires the nested facts to be satisfied as well}
        \end{grammar}
    \end{table}
\end{defn}

\begin{defn}[Bounds]
    We call the rightmost operand of a bounds fact the upper-bound and the leftmost operand the lower-bound.
\end{defn}

\begin{defn}[Trivial bounds]
    If a fact $F$ states $k_1 \leq_K \tau \leq_K k_2$ and $k_2 \leq k_1$, or $c_1 \leq_C \tau \leq_C c_2$ and $c_2 \leq c_1$, we call such a bounds fact trivial.
\end{defn}

\begin{lemma}[Trivial bounds]
    \label{trivBoundsObs}
    \begin{enumerate}
        \item If the bounds of a trivial bounds fact are equal, the type constesses of the types constrained by such a fact have to be the same and we can unify them.
        \item If, for a bounds fact, the upperbound is lower than the lowerbound, the fact cannot be satisfied.
    \end{enumerate}
\end{lemma}

\begin{defn}[Algorithm state]
    The algorithm state consists of the following finite variables
    % TODO: explain each
    \begin{itemize}
        \item Facts: $\mathcal{F} :: [\mathbb{W}]$
        \item Active type variables: $\mathcal{V} :: \subset \mathbb{V}$
        \item Forgotten type variables: $\mathcal{G} :: \subset \mathbb{V}$
        \item primitive patterns: $\mathcal{P} :: \subset \mathbb{P}$
        \item Type properties: $\mathcal{D} :: \subset \mathbb{D}$
        \item SubKinds: $\mathcal{K} :: \text{Directional graph}\ \mathbb{V}$
        \item KindBounds: $b_K :: \mathbb{V} \to \text{interval} \left[\mathbb{K}, \mathbb{K}\right]$
        \item SubConsts: $\mathcal{C} :: \text{Directional graph}\ \mathbb{V}$
        \item ConstBounds: $b_C :: \mathbb{V} \to \text{interval} \left[\mathbb{C}, \mathbb{C}\right]$
        \item Type explanation: $p :: \mathcal{V}_p \to \mathcal{P}; \mathcal{V}_p \subseteq \mathcal{V}$
        \item Type definition: $d :: \mathcal{V} \to \mathcal{D}$
        \item Result function: $u :: \mathcal{G} \to \mathcal{V}$
    \end{itemize}

    By $<_\mathcal{K}$ and $<_\mathcal{C}$, we understand that there exist a directional path between the given distinct operands in the respective graphs. We naturally extend this definitions to the other comparison operators (for example: $x =_\mathcal{K} y$ if there are paths back and forth between $x$ and $y$ in the graph $\mathcal{K}$ or $x = y$). % TODO: not that they can be equal

\end{defn}

\begin{defn}[Algorithm intrastate invariants]
    The algorithm is designed to have the following intrastate invariants:

    % TODO: invariant about u

    \begin{enumerate}
        \item Active and forgotten variables: $Var(\mathcal{F}) \cup Var(\mathcal{P}) \cup Var(\mathcal{D}) \cup Var(\mathcal{K}) \cup Var(\mathcal{C}) = Var(\mathcal{V})$ and $Var(\mathcal{V}) \cap Var(\mathcal{G}) = \emptyset$. \label{invVar}

        \item $\mathcal{V}$ and $\mathcal{D}$ are bijected by the type definition function $d$ with its inverse $d^{-1}$. The subset $\mathcal{V}_p \subseteq \mathcal{V}$ and the set $\mathcal{P}$ are bijected by the type explanation function $p$ and its inverse $p^{-1}$. Note that there generally are many types with no known explanation. \label{invPD}

        We expand the function applicability of $b_K$ and $b_C$ to type definitions is such a way that for an arbitrary type variable $v \in \mathcal{V}$, we have $b_K (d (v)) = b_K (c (d (v)))$, and similarly for $b_C$. In other words: applying $b_K$ to a type definition is equivalent to applying it to the type's kind (and similarly for $b_C$).

        We expand the applicability of $p$ and $d$ in such a way that for an arbitrary type variable $v \in \mathcal{V}_p$ it holds that $d(v) = d(p(v))$ and $p(v) = p(d(v))$.

        And finally, we expand the applicability of $t, k, c$ in such a way that for an arbitrary $v \in \mathcal{V}$ it holds that $t (v) = t (d (v))$, $k (v) = k (d (v))$, and $c (v) = c (d (v))$.

        \item 

        \item \label{invG} If we have two type variables $v, v' \in \mathcal{V}$ representing two types, then:
            \begin{enumerate}
                \item If $k (v) =_\mathcal{K} k (v')$, then: $k (v) = k(v')$. In other words, graph $\mathcal{K}$ has no strongly connected components (this will be true for $\mathcal{C}$ as well).
                \item If $c (v) =_\mathcal{C} c (v')$, then: $c (v) = c(v')$.
                \item If $b_K (k (v)) = b_K (k (v')) = [k_1, k_1]$ for some kind $k_1 \in \mathbb{K}$, then $k (v) = k (v')$.
                \item If $b_K (k (v)) = b_K (k (v')) = [k_1, k_2]$ for some kinds $k_1, k_2 \in \mathbb{K}$, $k_2 < k_1$, then $k (v) = k (v')$ and it is an invalid kind.
                \item If $b_C (c (v)) = b_C (c (v')) = [c_1, c_1]$ for some constness $c_1 \in \mathbb{C}$, then $c (v) = c (v')$.
                \item If $b_C (c (v)) = b_C (c (v')) = [c_1, c_2]$ for some constnesses $c_1, c_2 \in \mathbb{K}$, $c_2 < c_1$, then $c (v) = c (v')$ and it is an invalid constness.
                \item If $k (v) <_\mathcal{K} k (v')$, then for bounds $k_1, k_2, k_3, k_4$ such that $b_K (k (v)) = [k_1, k_3]$, and $b_K (k (v')) = [k_2, k_4]$ it holds that $k_1 \leq k_2$ and $k_3 \leq k_4$. Note that for new (and any non-stored) variables we will assume the least restrictive bounds, so adhering to this invariant means we update the bounds monotonically.
                \item If $c (v) <_\mathcal{C} c (v')$, then for bounds $c_1, c_2, c_3, c_4$ such that $b_C (c (v)) = [c_1, c_3]$, and $b_C (c (v')) = [c_2, c_4]$ it holds that $c_1 \leq c_2$ and $c_3 \leq c_4$.
            \end{enumerate}

        \item If a type represented by a type variable $v$ is explained ($v \in \mathcal{V}_p$), then $t (d (v)) = p(v) \left[ \tau := t (d (\tau)) | \tau \in \mathrm{free} (p (d))\right]$. In other words, the typing of the type represented by $v$ follows the typing generated from the typings of the types via which it is explained. \label{invT}
    \end{enumerate}
\end{defn}


\begin{defn}[Algorithm interstate invariants]
    The algorithm is designed to have the following interstate invariants: (we use the indices to distinguish a successor state variable from its predecessor, we will always assume $n < m \in \mathbb{N}$, we then use these indices in all derived functions too).

    \begin{enumerate}
        \item Forgotten variables stay forgotten: $v \in \mathcal{G}_n \Rightarrow v \in \mathcal{G}_m$.
        \item Forgotten variables used to be active: $v \in \mathcal{G}_m \Rightarrow \exists n . v \in \mathcal{V}_n$.
        \item All free variables from facts are considered by the algorithm: $v \in \mathrm{free} (\mathcal{F}_0) \Rightarrow v \in \mathcal{V}_0$.
        \item Assumed subtype constraints are monotonically getting restricted. For kinds: $v \in {\mathcal{V}}_n \Rightarrow {b_K}_m (k_m(u_m(v))) \subseteq {b_K}_n (k_n(v))$ and for constnesses: $v \in {\mathcal{V}}_n \Rightarrow {b_C}_m (c_m(u_m(v))) \subseteq {b_C}_n (c_n(v))$.
        \item Typings do not get forgotten: $v \in {\mathcal{V}}_n \Rightarrow \exists s . s(t_n(v)) = t_m(u_m (v))$.
        \item Explanations do not get forgotten: $v \in {\mathcal{V}_p}_n \Rightarrow \exists s . s(p_n(v)) = p_m(u_m (v))$.
        \item Results are results of results: $u_m = u_m (u_n)$.
        % TODO: add more constraints
    \end{enumerate}
\end{defn}

\begin{defn}[Unifications]
    In the scope of this algorithm we distinguish 4 types of unification. The algorithms for each will be the same, but their meaning is different.

    \begin{enumerate}
        \item Type unification: we unify two type variables that represent types, we then apply the resulting unification to all type variables considered by the algorithm. \label{tUni}
        \item Typing unification: we unify two typings of certain types, we then apply the resulting unification to all other typings considered by the algorithm.
        \item Kind unification: we unify two type variables that represent kinds of certain types, we then apply the resulting unification to all other variables representing kinds considered by the algorithm. \label{kUni}
        \item Constness unification: we unify two type variables that represent constnesses of certain types, we then apply the resulting unification to all other variables representing constnesses considered by the algorithm. \label{cUni} 
    \end{enumerate}
\end{defn}

\begin{defn}[Fresh variable]
    \label{freshVar}
    A fresh variable is chosen according to: \linebreak $\inf \left(\mathbb{V} \setminus \mathcal{V} \setminus \mathcal{G}\right)$.
\end{defn}

\begin{defn}[Algorithm middlesteps]
    \label{middlesteps}
    After each step of the algorithm that transforms one of the state variables (mainly $\mathcal{G}$,$\mathcal{P}$ or $\mathcal{D}$) into a new state, we perform the minimal necessary unifications to ``repair'' the bijections $d$ and $p$ (intrastate invariant \ref{invPD}, all unifications), to collapse any strongly connected components of the graphs $\mathcal{K}$ and  $\mathcal{C}$ and to remove any duplicate images of trivial bounds from $b_K$ and $b_C$ (intrastate invariant \ref{invG}, unifications \ref{kUni} and \ref{cUni}). This will be often performed recursively. We then apply the resulting combined unification (limited to just unifications \ref{tUni}) to the function $u$ so it satisfies the intrastate invariant \ref{invVar}. % TODO: fix wording
\end{defn}

\begin{lemma}[Algorithm middlesteps]
    The algorithm may (correctly) fail during the middlesteps. This can be shown by the observation \ref{trivBoundsObs}.
\end{lemma}

\begin{defn}[Introducing new (fresh) variable]
    \label{introVar}
    We introduce a new (fresh) variable by extending the sets $\mathcal{V}$ and $\mathcal{D}$
    and the type definition function $d$ by the argument $v$ and its image $i = (typing: v, constness: v, kind: v)$, formally: $\mathcal{V}' = \mathcal{V} \cup \{v\}$, $\mathcal{D}' = \mathcal{D} \cup \{i\}$, $d' = d [v := i]$. Where $v$ is the new (fresh) variable.
\end{defn}
\begin{defn}[Algorithm presteps]
    \label{presteps}
    All the (flat) facts generally use complicated types, before each step of the algorithm we replace the types in the observed fact with type variables that represent the types.

    The transformation is performed according to the observation \ref{typesObs}, changing the state variables $\mathcal{P}$, $\mathcal{D}$, $\mathcal{V}$, $p$ and $d$ accordingly and we set the typing of the type to adhere to the intrastate invariant \ref{invT}. For the yet unnamed types we perform the steps explained in definitions \ref{freshVar} and \ref{introVar}.
\end{defn}

\begin{defn}[Algorithm initialization]
    The initial state is: $\mathcal{V} = \mathcal{G} = \mathcal{P} = \mathcal{D} = \mathcal{K} = \mathcal{C} = \emptyset$, $p = d = u = b_K = b_C = \emptyset \to \emptyset$ and $\mathcal{F}$ is the list of facts to be satisfied.

    Before the algorithm starts, we introduce the variables encountered in $\mathcal{F}$ according to the definition \ref{introVar}.
\end{defn}

\begin{defn}[Algorithm steps]
    After the prestep (definition \ref{presteps}), we retrieve the first fact $f$ of $\mathcal{F}$ and then:

    \begin{itemize}
        \item If $f \equiv t_1 \sim t_2$, we unify $t_1$ and $t_2$
        \item If $f \equiv t_1 \sim_T t_2$, we unify the typings $t (d (t_1))$ and $t (d (t_2))$, resulting in the unification $m$ which we then apply to all typings in $\mathcal{D}$.
        \item If $f \equiv t_1 \leq_K t_2$, we add an edge $(t_1, t_2)$ to $\mathcal{K}$.
        \item If $f \equiv t_1 \leq_C t_2$, we add an edge $(t_1, t_2)$ to $\mathcal{C}$.
    \end{itemize}

    Then we perform the middlestep (definition \ref{middlesteps}) and continue to the next step.
\end{defn}

\section{Monomorphization}

