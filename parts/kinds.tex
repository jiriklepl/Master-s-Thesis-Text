\documentclass[12pt,a4paper]{article}
\usepackage[a-2u]{pdfx}

%% Character encoding: usually latin2, cp1250 or utf8:
\usepackage[utf8]{inputenc}

%% Prefer Latin Modern fonts
\usepackage{lmodern}

\usepackage{amsmath}        % extensions for typesetting of math
\usepackage{amsfonts}       % math fonts
\usepackage{amsthm}         % theorems, definitions, etc.
% \usepackage{bbding}         % various symbols (squares, asterisks, scissors, ...)
\usepackage{bm}             % boldface symbols (\bm)
\usepackage{algpseudocode}
\usepackage{bussproofs}

\newtheorem{definition}{Definition}

\begin{document}

\section{Kinds}

Kinds are constraints over types. These constraints are expressed via kind assignments akin to type assignments.

\begin{definition}[Kinds]
    $\mathbb{K}$ is the space of kinds given as follows:
    \begin{algorithmic}
        \State{$\mathbb{K} \Rightarrow \mathtt{Star}\ |\ \mathtt{Constraint}\ |\ \mathbb{K} \to \mathbb{K}$}
    \end{algorithmic}
    Just like with types, we will assume right associativity of the ``$\to$'' operator.
\end{definition}

$\mathtt{Star}$ is the kind of all data objects; namely runtime variables, constants and functions.

$\mathtt{Constraint}$ is the kind of class constraints. For example: given a type class $C$ with type parameters $a$ and $b$, then $C\ a\ b$ is a class constraint of the kind $\mathtt{Constraint}$.

\begin{definition}[Kind assignments]
    $\Gamma \vdash \tau : k$ means that given the context $\Gamma$ (a set of assignments), the type $\tau$ has the kind $k$. If this hold for every $\Gamma$, we write $\vdash \tau : k$. If $\Gamma$ is obvious or does not change throughout a proof, we write just $\tau : k$.
\end{definition}

\begin{definition}[Kind arity]
    We call a kind $k$ n-ary, if there exist $n$ kinds $l_1, \dots l_n$ such that given types $\tau : k$, $\sigma_1 : l_1, \dots \sigma_{n} : l_{n}$ the type $\tau\ \sigma_1 \dots \sigma_n$ is valid and its kind is either $\mathtt{Star}$ or $\mathtt{Constraint}$.
    
    Kind $k$ has arity of 0 if and only if it is either $\mathtt{Star}$ or $\mathtt{Constraint}$.
\end{definition}

\begin{definition}[Context as a partial function]
    In the scope of this thesis, we assume all kinds be mono-kinds (if $\Gamma \vdash \tau : k$ and $\Gamma \vdash \tau : k'$, then $k \equiv k'$). We will define rules, for which this will hold. And because of this, we can define applying $\Gamma$ to the type $\tau$ as $\Gamma(\tau) := k \Leftrightarrow \Gamma \vdash \tau : k$.
\end{definition}

\begin{definition}[Kinding rules (incomplete)]
    \begin{prooftree}
        \AxiomC{$\tau : k \in \Gamma$}
        \UnaryInfC{$\Gamma \vdash \tau : k$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash x : \tau$}
        \UnaryInfC{$\Gamma \vdash \tau : \mathtt{Star}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\Gamma \vdash \tau : k \to l$}
        \AxiomC{$\Gamma \vdash \sigma : k$}
        \BinaryInfC{$\Gamma \vdash \tau \sigma : l$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{class $C$ has parameters $\tau_1, \dots \tau_n$, superclasses $D_1, \dots D_m$ within a global context $\Gamma$}
        \UnaryInfC{class context $\Gamma_C = \Gamma \cup \{\tau_1 : k_1, \dots \tau_n : k_n, D_1 : \Gamma_{D_1}(D_1), \dots D_m : \Gamma_{D_m}(D_m), \text{method typings}\},$}
        \noLine
        \UnaryInfC{$\Gamma_C \vdash C : k_1 \to k_2 \to \cdots \to k_n \to \mathtt{Constraint}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{struct $S$ has parameters $\tau_1, \dots \tau_n$ within a global context $\Gamma$}
        \UnaryInfC{struct context $\Gamma_S = \Gamma \cup \{\tau_1 : k_1, \dots \tau_n : k_n, \text{field typings}\},$}
        \noLine
        \UnaryInfC{$\Gamma_S \vdash S : k_1 \to k_2 \to \cdots \to k_n \to \mathtt{Star}$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{function $f$ has parameters $x_1 : \tau_1, \dots x_n : \tau_n$, return type $\sigma$, class constraints $D_1, \dots D_m$ within a global context $\Gamma$}
        \UnaryInfC{function context $\Gamma_f = \Gamma \cup \{x_1 : \tau_1, \dots x_n : \tau_n, \sigma: \mathtt{Star}, D_1 : \Gamma_{D_1}(D_1), \dots D_m : \Gamma_{D_m}(D_m)\}$,}
        \noLine
        \UnaryInfC{$\Gamma_f \vdash f : (x_1, \dots x_n) \to \sigma$}
    \end{prooftree}
    \begin{prooftree}
        \AxiomC{$\Gamma_x \vdash x : \Gamma_x (x)$}
        \UnaryInfC{$\Gamma \vdash x : \Gamma_x(x)$}
    \end{prooftree}
\end{definition}

\begin{definition}[Kind ordering (completing the kinding rules)]
    We define the ordering of kinds as the transitive closure generated by the following rules:
    \begin{itemize}
        \item $\mathtt{Star} < \mathtt{Star} \to \mathtt{Star}$
        \item $k \to l \wedge k' < k \Rightarrow k' \to l < k \to l$
        \item $k \to l \wedge l' < l \Rightarrow k \to l' < k \to l$
    \end{itemize}

    % TODO: uz neni definice
    Then, if the inference for kinds is inconclusive (within the scope of type classes and structs), we assume the infimal kind assignments for which the kinding rules hold.
\end{definition}

\end{document}
